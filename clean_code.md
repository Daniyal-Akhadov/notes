Tags: #чистый_код

# Глава 1: Вступление от ГЕНИЕВ 

1. Бог в мелочах. Великий архитектор сам подбирал ручки дверей, так как мелочи важны.
2. Хорошая практика программирования требует: сосредоточенности, силы духа и мышления.
3. Безжалостно перерабатывай свой код. Переписывай его каждую неделю, месяц и год с нуля, чтобы не стало хуже.
4. Пиши код не только чтобы он хорошо работал, но и легко читался.
5. Изучи принципы, паттерны. Далее используя их внедряй эти практики себе в пальцы. Так во всем. Получи теорию, а дальше пытайся ее использовать. И в математике дают формулы и объясняют их, далее решаешь задачу тысячу раз обосравшись, но решив её. И если на велике катаешься, сначала краткая теория, а далее едешь и падаешь, пока прямо не поедешь.
6. Потом равносильно никогда. Поэтому не вздумай отложить изменения кода на завтра, ибо ты не станешь этого делать. Тебе либо прилетят новые задачи, либо тебе будет лень.
7. Плохой код искушает других читателей кода писать плохой код. Когда читатель решается рефакторить плохой код, он делает это также плохо в соответствии с исходным кодом. Всегда помни, что плохой код похож на здание, в котором разбито одно окно. Люди склонны как гиены добивать бедное маленькое животное. Они засоряют его ещё сильней. Уже два разбитых окна и мусор внутри. Далее заходят бомжи и начинают ссать и срать на всё подряд. 
   И так хуже и хуже.
8. Код должен приносить удовольствие при чтении и силу духа для того чтобы ровняться с ним.
9. Чистый код решает только одну задачу в отличии от говна-кода, который решает сразу несколько задач. Каждый класс, метод, переменная решает что - либо целенаправленно, не отвлекаясь на другие задачи
10. Объемистый код (где много строк) - ужасен. Чем меньше код, тем легче читать. Чем меньше тем лучше.
11. Код прекрасен, когда функция достигает примерно ожидаемого результата
12. Старайся сделать код предшественников лучше чем он был. Необязательно глобально. Просто дай имена им лучше. Измени сложную цепочку if-ов. Выдели метод из большого метода и т.д. Сделай место лучше, чем оно было до тебя.

# Глава 2: Имена переменных.

1. Мы всегда даём имена, не только классам и переменным, но и методам, пакетам, билдам и т.д. Поэтому этому стоит уделить внимание.
2. Имена должны передавать намерения программиста. Это займёт много времени, но окупится в будущем. Изменяйте их если найдёте более удачные варианты. Этим ты упростишь жизнь каждому, кто читает код. Имя должно объяснять, что на главные вопросы: почему переменная (и т.д.) существует, что она делает и как используется. 
3. Если имя требует комментариев, значит, она не передаёт намерения программиста.
   Пример:
   ```java
    int d; // Прошедшее время
	```
   Что это вообще может значить? Это же говно мамонта, а не название.
   Нет ни указании о времени, нет и того в чём измеряется время.
   Лучше так: 
   ```java
   int elapsedTimeInDays;
   int daysSinceCreation; 
   int daysSinceModification; 
   int fileAgeInDays
	``` 
	Этим имена значительно лучше прежнего. Существенные имена значительно облегчают понимание и модификацию кода.
4. Задай себе вопрос: почему мы не сразу можем сказать, что делает этот код?
5. Код должен быть очевидным.
6. 
   ```java
  public List getThem() { 
	  List list1 = new ArrayList(); 
	  
	  for (int[] x : theList) 
		  if (x[0] == 4) 
		  list1.add(x); 
		  
	  return list1; 
  }
```
   Код подразумевает, что мы знаем ответы на вопросы (пример): 
   1. Какие данные хранятся в theList? 
   2. Чем так важен элемент theList с нулевым индексом? 
   3. Какой особый смысл имеет значение 4? 
   4. Как будет использоваться возвращаемый список?
   
   Смотри как сильно улучшился код, когда разработчик просто изменил имена.
	   
	```java
public List getFlaggedCells() {  
    List flaggedCells = new ArrayList();  
  
    for (int[] cell : gameBoard)  
        if (cell[STATUS_VALUE] == FLAGGED)  
            flaggedCells.add(cell);
              
    return flaggedCells;  
}
```
	Можно ещё сильней улучшить код, за счёт того, что мы будем использовать вместо массив чисел (int), класс Cell, смотри:
	```java
	public List<Cell> getFlaggedCells() {  
	    List<Cell> flaggedCells = new ArrayList<Cell>();  
	    
	    for (Cell cell : gameBoard)  
	        if (cell.isFlagged())  
            flaggedCells.add(cell);  
            
	    return flaggedCells;  
	}```

8. Избегай дезинформации, например hp для гипотенузы может ввести в ступор, ибо оно также может ассоциироваться с Unix системой
9. Не нужно присваивать переменным слова по типу accountList (речь о List), если только он не означает список в Java. Если ты что - то другое имеешь в виду, то назови лучше accounts
10. Остерегайся малозаметным отличий в переменных. 
    ![image](https://github.com/user-attachments/assets/4c8d40b6-7ff3-4c21-bd1c-27c48bd6c39c)

11. Разработчик ищет переменные по именам, а не комментариям, и списка методов
12. Если имена различаются, значит они обозначают разные понятия. Имеется в виду, что раз ты решил удовлетворить компилятор и назвал переменные: accounts и accountsList, то ты явно что - то делаешь не так. Так твои переменные не будут нести понимания того, что представляют собой имена и зачем они вообще нужны.
    ![image](https://github.com/user-attachments/assets/8ddd7441-8d6a-4352-9925-2beb80a37c13)
13. Используй удобопроизносимые имена.
    ![image](https://github.com/user-attachments/assets/5666dfb7-b093-409e-aaeb-1e0efd7abb23)

14. Выбирай имена удобные для поиска
    ![image](https://github.com/user-attachments/assets/067d4457-18be-49ce-9352-cb9960435d53)

15. Используй имя интерфейса без `I`, например `IShapeFactory`, лучше сразу `ShapeFactory`, если класс реализующий данный интерфейс один, то нормальной практикой назвать его `ShapFactoryImpl`. Когда ты имя пишешь без префикса `I`, то ты даёшь более содержательные имя интерфейсам
16. Профессионал должен понимать, что ясность превыше всего, поэтому когда взбредёт идея назвать переменную `a` для ссылки на БД, то подумай тысячу раз, а будет ли понятно остальным
17. Имена классов должны представлять собой имена существительные и их комбинации. Лучше также не использовать бессодержательные имена по типу: Info, Manager, Data, Processor. Имена классов не должны быть глаголами.
18. Имена методов - это глаголы.
19. Когда ты перегружаешь конструкторы, то лучше сделать их приватными и создавать статические методы-фабрики.
20. Выбирай одно имя для каждой концепции и ей придерживайся. Простыми словами, имеется в виду, что если ты уже используешь get где в одном классе, то юзай везде `get`, а не `retrieve`
    ![image](https://github.com/user-attachments/assets/860b690b-f2c7-4255-8485-37dfa64e1612)

21. Старайтесь не использовать одно слово в двух смыслах В сущности, обозначение двух разных идей одним термином — это каламбур. Речь о том, что add для добавления уникальных значений, add для добавления неуникальных значений, insert для добавления значений --- всё это каламбур. Используй для вставки неуникальных значений append, для уникальных add, insert для вставки в любую позицию
    ![image](https://github.com/user-attachments/assets/f14920e6-dfa1-4eca-9875-46ee43b84dfe)

22. Используйте имена из пространства решения. Имеется в виду все знают паттерны проектирования, все знают о алгоритмах. Так что не бойся приписать Visitor к классу, когда будешь использовать этот паттерн. Если бинарный поиск используешь, то не бойся также его туда приписать.
23. Используйте имена из пространства задачи (речь идёт о доменной области)
24. ![image](https://github.com/user-attachments/assets/7d072c33-f654-4f06-a952-24c2ad349979)


# Глава 3: Функции
1. Главные вопросы: 
   Что делает функцию такой понятной и удобочитаемой? Как заставить функцию передавать намерения разработчика? Какие атрибуты функции помогут случайному читателю составить интуитивное представление о выполняемых ей задачах?
2. Первое правило: функции должны быть компактными Второе правило: функции должны быть еще компактнее! Функции должны быть очень маленькие. Желательно, чтобы функция была не длинней 20 строк кода.
3. Блоки в командах if, else, while и т.д. должны состоять из одной строки, в которых обычно находится метод. 
   Функции не должны содержать вложенных структур, так как это приводит к их увеличению Максимальный уровень отступов в функции не должен превышать одного-двух Разумеется, это упрощает чтение и понимание функций
4. ФУНКЦИЯ ДОЛЖНА ВЫПОЛНЯТЬ ТОЛЬКО ОДНУ ОПЕРАЦИЮ ОНА ДОЛЖНА ВЫПОЛНЯТЬ ЕЕ ХОРОШО И НИЧЕГО ДРУГОГО ОНА ДЕЛАТЬ НЕ ДОЛЖНА. 
5. Все методы в методе, должны быть на одном уровне абстракции. Что это значит? Тут стоит дать ясное понимание того, что такое абстракция и как её определить. Мне понравилось определение от GPT.

**Что такое абстракция?**
   
Абстракция — это процесс выделения основных характеристик объекта, игнорируя детали, которые не важны в текущем контексте. В программировании абстракция помогает управлять сложностью, упрощая понимание системы.

```java
Пример на Java:

// Пример абстракции с помощью абстрактного класса
abstract class Animal {
    abstract void makeSound(); // Абстрактный метод
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Гав");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("Мяу");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();
        
        myDog.makeSound(); // Вывод: Гав
        myCat.makeSound(); // Вывод: Мяу
    }
}
```

В этом примере класс Animal демонстрирует абстракцию, так как он не содержит конкретных реализаций звуков, но описывает, что животные могут их издавать. Классы Dog и Cat предоставляют конкретные реализации этого поведения. 

**Как определить уровень абстракции?**

Когда мы говорим о высоком уровне абстракции в контексте интерфейсов и абстрактных классов, мы имеем в виду, что интерфейсы позволяют нам определять поведение без привязки к конкретным реализациям. Однако, как вы правильно заметили, реализация метода `area()` в классе `Circle` — это конкретная реализация, и в этом контексте она может быть рассмотрена как низкий уровень абстракции.

### Правильное понимание

1. **Интерфейс**: Определяет контракт (что должно быть реализовано), но не содержит конкретной логики. В этом случае интерфейс `Shape` определяет, что любой класс, реализующий его, должен иметь метод `area()`, но не говорит, как именно этот метод должен работать.

2. **Конкретная реализация**: Класс `Circle` предоставляет конкретный способ вычисления площади. Это делает его реализацию более низким уровнем абстракции, поскольку мы видим детали того, как именно вычисляется площадь круга.

### Пример более высокого уровня абстракции

Чтобы продемонстрировать более высокий уровень абстракции, мы можем рассмотреть использование абстрактного класса или интерфейса, который не содержит конкретной логики, а только определяет, что должно быть сделано.

```java
interface Shape {
    double area(); // Определяет поведение, но не реализует его
}

class Rectangle implements Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    public double area() {
        return width * height; // Конкретная реализация
    }
}
```

### Комбинирование абстракций

Также можно создать более абстрактные методы, которые могут принимать другие объекты или параметры, что позволит избежать жесткой привязки к конкретным реализациям.

```java
class ShapeCalculator {
    public double calculateArea(Shape shape) {
        return shape.area(); // Высокий уровень абстракции: мы не знаем, как именно считается площадь
    }
}
```

### Заключение

Таким образом, когда мы говорим о высоком уровне абстракции, мы имеем в виду использование интерфейсов и абстрактных классов для определения поведения, не углубляясь в детали реализации. Конкретная реализация, как в случае с методом `area()` в классе `Circle`, является более низким уровнем абстракции. 

   5 . Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта функция выполняет одну операцию. В конце концов, функции пишутся прежде всего для разложения более крупной концепции (иначе говоря, имени функции) на последовательность действий на следующем уровне абстракции.
6. Секции в функциях. Взгляните на листинг 47 на с98 Обратите внимание: функция generatePrimes разделена на секции (объявления, инициализация, отбор) Это очевидный признак того, что функция выполняет более одной операции Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.
7. За каждой функцией должны следовать функции следующего уровня абстракции Это позволяет читать код, последовательно спускаясь по уровням абстракции в ходе чтения списка функций Я называю такой подход «правилом понижения».
8. Длинный `switch` и `if/else` - это ужасно. Их нужно минимизировать за счёт абстрактной фабрики или Command Pattern.
9. Имена методов должны быть максимально специализированы. Чтобы лучше подобрать имя метода, он должен делать как можно меньше. Если он большой, значит выбрать ему имя будет труднее.
10. Не бойся использовать длинные имена. Чем они длиннее, тем содержательней. Опробуй сразу несколько имён. Потрать на это время. Сначала присвой одно имя и прочти код, как он читается. Далее второе имя. Как оно читается? И т.д.
11. Параметров метода должно быть как можно меньше. В идеальном случае должно быть равно 0. Если три и более параметров, то нужно такое избегать. Например тестировать методы с 0 параметров шикарно! С 1 уже сложнее, ибо надо подбирать различные варианты аргументов. Если параметров 2 (упаси господь), то ещё сложнее. А теперь представь, что их 3 и больше.
12. Аргумент в методе не должен изменяться. Имеется в виду, что мы даём данные и получаем их через return. Если же мы и return получаем и изменённый параметр, то это капец.
13. Аргументы-флаги уродливы Передача логического значения функции — воистину ужасная привычка Она немедленно усложняет сигнатуру метода, громко провозглашая, что функция выполняет более одной операции При истинном значении флага выполняется одна операция, а при ложном — другая!
14. ![image](https://github.com/user-attachments/assets/e0a88640-1151-464c-bc04-8e4712b2f405)

15. Никаких побочных эффектов. Это когда функция обещает сделать одно, а делает абсолютно другое. Ваша функция обещает делать что-то одно, но делает что-то другое, скрытое от пользователя Иногда она вносит неожиданные изменения в переменные своего класса — скажем, присваивает им значения параметров, переданных функции, или глобальных переменных системы.
16. Выходные аргументы - зло. Я не смог нормально понять этот параграф, поэтому попросил GPT сделать это за меня и мне стал ясен параграф:
### Что значит "использование методов внутри классов"?

Когда мы говорим о **методах внутри классов**, мы имеем в виду функции, которые определены в классе и работают с данными этого класса. Эти методы могут изменять состояние объекта, например, добавлять текст или производить другие изменения.

### Что такое "выходные аргументы"?

**Выходные аргументы** — это параметры, которые мы передаём в функцию и которые могут изменяться внутри этой функции. После выполнения функции эти параметры могут содержать новые значения, и это может вызывать путаницу.

### Почему использование методов лучше?

1. **Ясность**: Когда вы вызываете метод, например, `myText.addText()`, сразу понятно, что происходит. Вы знаете, что метод `addText` изменяет текст внутри объекта `myText`. Вам не нужно беспокоиться о том, что происходит с аргументами, переданными в функцию.

2. **Инкапсуляция**: Вся логика изменения данных находится внутри класса. Это означает, что вам не нужно знать, как именно работает метод, чтобы его использовать. Вы просто вызываете его и получаете результат.

3. **Легкость в поддержке**: Если вам нужно изменить, как работает добавление текста, вы можете сделать это в одном месте — в методе `addText`. Это упрощает поддержку и изменение кода в будущем.

### Пример

Рассмотрим, как это выглядит на практике:

#### С использованием выходных аргументов:

```java
public void addText(StringBuilder text) {
    text.append(" - добавлено");
}
```

Здесь неясно, что происходит с переменной `text`, и нам нужно помнить, что она изменится после вызова функции.

#### С использованием методов внутри класса:

```java
public class MyText {
    private StringBuilder text;

    public MyText(String initialText) {
        this.text = new StringBuilder(initialText);
    }

    public void addText() {
        text.append(" - добавлено");
    }

    public String getText() {
        return text.toString();
    }
}
```

Здесь мы видим, что метод `addText` изменяет состояние объекта `MyText`. Мы просто вызываем этот метод, и нам не нужно беспокоиться о том, как он работает. Это делает код более понятным и логичным.

### Итог

Использование методов внутри классов вместо выходных аргументов помогает избежать путаницы, потому что:

- Мы точно знаем, что происходит с данными.
- Логика изменения данных сосредоточена в одном месте.
- Код становится более структурированным и легче читаемым.
  
	17 . Разделение команд и запросов
        ![image](https://github.com/user-attachments/assets/307b8b76-629b-483f-9ed2-b62a8aa347fb)

	![image](https://github.com/user-attachments/assets/193d099f-c0b1-49eb-b728-e61c850cdd1e)

	18 . Вместо кодов ошибки используй исключения. Вот к чему приводят коды ошибок: ![image](https://github.com/user-attachments/assets/9ee81191-ad39-4429-8d27-fdf7437b5c56)

	И вот к чему приводит использование исключений:
	![Uploading image.png…]()

  	19 . try/catch надо изолировать в другие методы. То что внутри try/catch должно быть одной строкой, а не несколько. Try-catch уродливы сами по себе и их трудно читать. ![image](https://github.com/user-attachments/assets/496af1fc-876c-4565-b035-50d900ccfa5e)

	Таким образом мы читаем delete и понимаем что она обрабатывает ошибки, в то время как основная логика лежит в `deletePageAndAllReferences`.
	![image](https://github.com/user-attachments/assets/4fec2828-3e81-4151-a4b4-2305a437b5e8)

	20 . DRY. Если надо будет изменить что - то, то придётся менять сразу в нескольких местах.
	21 . Как писать такие функции? Для этого ты просто их пиши, а далее уже причёсывай пока они не дойдут до твоего идеала.
	22 .  Слова Дяди Боба ![image](https://github.com/user-attachments/assets/8c3731af-e51a-41a5-b06d-745e17d0d366)



