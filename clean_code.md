Tags: #чистый_код

# Глава 1: Вступление от ГЕНИЕВ 

1. Бог в мелочах. Великий архитектор сам подбирал ручки дверей, так как мелочи важны.
2. Хорошая практика программирования требует: сосредоточенности, силы духа и мышления.
3. Безжалостно перерабатывай свой код. Переписывай его каждую неделю, месяц и год с нуля, чтобы не стало хуже.
4. Пиши код не только чтобы он хорошо работал, но и легко читался.
5. Изучи принципы, паттерны. Далее используя их внедряй эти практики себе в пальцы. Так во всем. Получи теорию, а дальше пытайся ее использовать. И в математике дают формулы и объясняют их, далее решаешь задачу тысячу раз обосравшись, но решив её. И если на велике катаешься, сначала краткая теория, а далее едешь и падаешь, пока прямо не поедешь.
6. Потом равносильно никогда. Поэтому не вздумай отложить изменения кода на завтра, ибо ты не станешь этого делать. Тебе либо прилетят новые задачи, либо тебе будет лень.
7. Плохой код искушает других читателей кода писать плохой код. Когда читатель решается рефакторить плохой код, он делает это также плохо в соответствии с исходным кодом. Всегда помни, что плохой код похож на здание, в котором разбито одно окно. Люди склонны как гиены добивать бедное маленькое животное. Они засоряют его ещё сильней. Уже два разбитых окна и мусор внутри. Далее заходят бомжи и начинают ссать и срать на всё подряд. 
   И так хуже и хуже.
8. Код должен приносить удовольствие при чтении и силу духа для того чтобы ровняться с ним.
9. Чистый код решает только одну задачу в отличии от говна-кода, который решает сразу несколько задач. Каждый класс, метод, переменная решает что - либо целенаправленно, не отвлекаясь на другие задачи
10. Объемистый код (где много строк) - ужасен. Чем меньше код, тем легче читать. Чем меньше тем лучше.
11. Код прекрасен, когда функция достигает примерно ожидаемого результата
12. Старайся сделать код предшественников лучше чем он был. Необязательно глобально. Просто дай имена им лучше. Измени сложную цепочку if-ов. Выдели метод из большого метода и т.д. Сделай место лучше, чем оно было до тебя.

# Глава 2: Имена переменных.

1. Мы всегда даём имена, не только классам и переменным, но и методам, пакетам, билдам и т.д. Поэтому этому стоит уделить внимание.
2. Имена должны передавать намерения программиста. Это займёт много времени, но окупится в будущем. Изменяйте их если найдёте более удачные варианты. Этим ты упростишь жизнь каждому, кто читает код. Имя должно объяснять, что на главные вопросы: почему переменная (и т.д.) существует, что она делает и как используется. 
3. Если имя требует комментариев, значит, она не передаёт намерения программиста.
   Пример:
   ```java
    int d; // Прошедшее время
	```
   Что это вообще может значить? Это же говно мамонта, а не название.
   Нет ни указании о времени, нет и того в чём измеряется время.
   Лучше так: 
   ```java
   int elapsedTimeInDays;
   int daysSinceCreation; 
   int daysSinceModification; 
   int fileAgeInDays
	``` 
	Этим имена значительно лучше прежнего. Существенные имена значительно облегчают понимание и модификацию кода.
4. Задай себе вопрос: почему мы не сразу можем сказать, что делает этот код?
5. Код должен быть очевидным.
6. 
   ```java
  public List getThem() { 
	  List list1 = new ArrayList(); 
	  
	  for (int[] x : theList) 
		  if (x[0] == 4) 
		  list1.add(x); 
		  
	  return list1; 
  }
```
   Код подразумевает, что мы знаем ответы на вопросы (пример): 
   1. Какие данные хранятся в theList? 
   2. Чем так важен элемент theList с нулевым индексом? 
   3. Какой особый смысл имеет значение 4? 
   4. Как будет использоваться возвращаемый список?
   
   Смотри как сильно улучшился код, когда разработчик просто изменил имена.
	   
	```java
public List getFlaggedCells() {  
    List flaggedCells = new ArrayList();  
  
    for (int[] cell : gameBoard)  
        if (cell[STATUS_VALUE] == FLAGGED)  
            flaggedCells.add(cell);
              
    return flaggedCells;  
}
```
	Можно ещё сильней улучшить код, за счёт того, что мы будем использовать вместо массив чисел (int), класс Cell, смотри:
	```java
	public List<Cell> getFlaggedCells() {  
	    List<Cell> flaggedCells = new ArrayList<Cell>();  
	    
	    for (Cell cell : gameBoard)  
	        if (cell.isFlagged())  
            flaggedCells.add(cell);  
            
	    return flaggedCells;  
	}```

8. Избегай дезинформации, например hp для гипотенузы может ввести в ступор, ибо оно также может ассоциироваться с Unix системой
9. Не нужно присваивать переменным слова по типу accountList (речь о List), если только он не означает список в Java. Если ты что - то другое имеешь в виду, то назови лучше accounts
10. Остерегайся малозаметным отличий в переменных. 
    ![image](https://github.com/user-attachments/assets/4c8d40b6-7ff3-4c21-bd1c-27c48bd6c39c)

11. Разработчик ищет переменные по именам, а не комментариям, и списка методов
12. Если имена различаются, значит они обозначают разные понятия. Имеется в виду, что раз ты решил удовлетворить компилятор и назвал переменные: accounts и accountsList, то ты явно что - то делаешь не так. Так твои переменные не будут нести понимания того, что представляют собой имена и зачем они вообще нужны.
    ![image](https://github.com/user-attachments/assets/8ddd7441-8d6a-4352-9925-2beb80a37c13)
13. Используй удобопроизносимые имена.
    ![image](https://github.com/user-attachments/assets/5666dfb7-b093-409e-aaeb-1e0efd7abb23)

14. Выбирай имена удобные для поиска
    ![image](https://github.com/user-attachments/assets/067d4457-18be-49ce-9352-cb9960435d53)

15. Используй имя интерфейса без `I`, например `IShapeFactory`, лучше сразу `ShapeFactory`, если класс реализующий данный интерфейс один, то нормальной практикой назвать его `ShapFactoryImpl`. Когда ты имя пишешь без префикса `I`, то ты даёшь более содержательные имя интерфейсам
16. Профессионал должен понимать, что ясность превыше всего, поэтому когда взбредёт идея назвать переменную `a` для ссылки на БД, то подумай тысячу раз, а будет ли понятно остальным
17. Имена классов должны представлять собой имена существительные и их комбинации. Лучше также не использовать бессодержательные имена по типу: Info, Manager, Data, Processor. Имена классов не должны быть глаголами.
18. Имена методов - это глаголы.
19. Когда ты перегружаешь конструкторы, то лучше сделать их приватными и создавать статические методы-фабрики.
20. Выбирай одно имя для каждой концепции и ей придерживайся. Простыми словами, имеется в виду, что если ты уже используешь get где в одном классе, то юзай везде `get`, а не `retrieve`
    ![image](https://github.com/user-attachments/assets/860b690b-f2c7-4255-8485-37dfa64e1612)

21. Старайтесь не использовать одно слово в двух смыслах В сущности, обозначение двух разных идей одним термином — это каламбур. Речь о том, что add для добавления уникальных значений, add для добавления неуникальных значений, insert для добавления значений --- всё это каламбур. Используй для вставки неуникальных значений append, для уникальных add, insert для вставки в любую позицию
    ![image](https://github.com/user-attachments/assets/f14920e6-dfa1-4eca-9875-46ee43b84dfe)

22. Используйте имена из пространства решения. Имеется в виду все знают паттерны проектирования, все знают о алгоритмах. Так что не бойся приписать Visitor к классу, когда будешь использовать этот паттерн. Если бинарный поиск используешь, то не бойся также его туда приписать.
23. Используйте имена из пространства задачи (речь идёт о доменной области)
24. ![image](https://github.com/user-attachments/assets/7d072c33-f654-4f06-a952-24c2ad349979)


# Глава 3: Функции
1. Главные вопросы: 
   Что делает функцию такой понятной и удобочитаемой? Как заставить функцию передавать намерения разработчика? Какие атрибуты функции помогут случайному читателю составить интуитивное представление о выполняемых ей задачах?
2. Первое правило: функции должны быть компактными Второе правило: функции должны быть еще компактнее! Функции должны быть очень маленькие. Желательно, чтобы функция была не длинней 20 строк кода.
3. Блоки в командах if, else, while и т.д. должны состоять из одной строки, в которых обычно находится метод. 
   Функции не должны содержать вложенных структур, так как это приводит к их увеличению Максимальный уровень отступов в функции не должен превышать одного-двух Разумеется, это упрощает чтение и понимание функций
4. ФУНКЦИЯ ДОЛЖНА ВЫПОЛНЯТЬ ТОЛЬКО ОДНУ ОПЕРАЦИЮ ОНА ДОЛЖНА ВЫПОЛНЯТЬ ЕЕ ХОРОШО И НИЧЕГО ДРУГОГО ОНА ДЕЛАТЬ НЕ ДОЛЖНА. 
5. Все методы в методе, должны быть на одном уровне абстракции. Что это значит? Тут стоит дать ясное понимание того, что такое абстракция и как её определить. Мне понравилось определение от GPT.

**Что такое абстракция?**
   
Абстракция — это процесс выделения основных характеристик объекта, игнорируя детали, которые не важны в текущем контексте. В программировании абстракция помогает управлять сложностью, упрощая понимание системы.

```java
Пример на Java:

// Пример абстракции с помощью абстрактного класса
abstract class Animal {
    abstract void makeSound(); // Абстрактный метод
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Гав");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("Мяу");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();
        
        myDog.makeSound(); // Вывод: Гав
        myCat.makeSound(); // Вывод: Мяу
    }
}
```

В этом примере класс Animal демонстрирует абстракцию, так как он не содержит конкретных реализаций звуков, но описывает, что животные могут их издавать. Классы Dog и Cat предоставляют конкретные реализации этого поведения. 

**Как определить уровень абстракции?**

Когда мы говорим о высоком уровне абстракции в контексте интерфейсов и абстрактных классов, мы имеем в виду, что интерфейсы позволяют нам определять поведение без привязки к конкретным реализациям. Однако, как вы правильно заметили, реализация метода `area()` в классе `Circle` — это конкретная реализация, и в этом контексте она может быть рассмотрена как низкий уровень абстракции.

### Правильное понимание

1. **Интерфейс**: Определяет контракт (что должно быть реализовано), но не содержит конкретной логики. В этом случае интерфейс `Shape` определяет, что любой класс, реализующий его, должен иметь метод `area()`, но не говорит, как именно этот метод должен работать.

2. **Конкретная реализация**: Класс `Circle` предоставляет конкретный способ вычисления площади. Это делает его реализацию более низким уровнем абстракции, поскольку мы видим детали того, как именно вычисляется площадь круга.

### Пример более высокого уровня абстракции

Чтобы продемонстрировать более высокий уровень абстракции, мы можем рассмотреть использование абстрактного класса или интерфейса, который не содержит конкретной логики, а только определяет, что должно быть сделано.

```java
interface Shape {
    double area(); // Определяет поведение, но не реализует его
}

class Rectangle implements Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    public double area() {
        return width * height; // Конкретная реализация
    }
}
```

### Комбинирование абстракций

Также можно создать более абстрактные методы, которые могут принимать другие объекты или параметры, что позволит избежать жесткой привязки к конкретным реализациям.

```java
class ShapeCalculator {
    public double calculateArea(Shape shape) {
        return shape.area(); // Высокий уровень абстракции: мы не знаем, как именно считается площадь
    }
}
```

### Заключение

Таким образом, когда мы говорим о высоком уровне абстракции, мы имеем в виду использование интерфейсов и абстрактных классов для определения поведения, не углубляясь в детали реализации. Конкретная реализация, как в случае с методом `area()` в классе `Circle`, является более низким уровнем абстракции. 

   5 . Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта функция выполняет одну операцию. В конце концов, функции пишутся прежде всего для разложения более крупной концепции (иначе говоря, имени функции) на последовательность действий на следующем уровне абстракции.
6. Секции в функциях. Взгляните на листинг 47 на с98 Обратите внимание: функция generatePrimes разделена на секции (объявления, инициализация, отбор) Это очевидный признак того, что функция выполняет более одной операции Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.
7. За каждой функцией должны следовать функции следующего уровня абстракции Это позволяет читать код, последовательно спускаясь по уровням абстракции в ходе чтения списка функций Я называю такой подход «правилом понижения»
