Git - система распределённого контроля версий.

Зачем он нужен?

Предположим, что ты пишешь какой - то документ, например курсовая, либо какой - то код, тут не так уже и важно. 

Когда мы работаем над этим документом, мы вносим изменения. 

**Первый вариант:**

В классическом подходе мы делаем:
1. Версия 1
2. Версия 2
3. и т.д.

![image](https://github.com/user-attachments/assets/cf87cce5-5fef-4fdc-83f4-36d6fce1429b)

По сути такая система будет работать, однако мы будем каждый раз создавать и далее хранить этот новый файл и все предыдущие, чтобы откатиться.

**Второй вариант:**

Убирать все старые файлы и оставить только текущую:

![image](https://github.com/user-attachments/assets/0e339d59-842f-4ba6-8d29-2cf430618d22)
Но тут тебя просят убрать текущую версию, ибо она говно и вернуться к предыдущей. Но где она? А ты проебался, ведь удалил всё это.

Таким образом нет возможности откатиться назад.

**Третий вариант и самый лучший**:

Система контроля версий. Таким образом мы имеем один файл на жёстком диске. И каждый раз мы можем видеть, что мы что - то изменили относительно предыдущей версии. Например, мы добавили новую строчку кода.

![image](https://github.com/user-attachments/assets/ec894354-4e33-426b-8da0-83d2332cd106)

Таким образом единственное, что мы будем иметь - это сам файл и саму систему контроля версий которая отслеживает изменения и хранит их у себя.

## Что даёт Git?

1. Система контроля версий
2. Распределённое хранение кода  (имеется в виду сразу на сервере, на твоём компе и т.д.). Это допускается путём отправки твоего Git на удалённый сервер, например GitHub 
3. Ветки и слияние для параллельной работы фич (это далее)
4. Простое перемещение по истории изменений


## Основные понятия

Основная задача Git - хранить и отслеживать изменения, например папки.

![image](https://github.com/user-attachments/assets/51b7c738-e918-45e7-ab89-bfc2a70b7214)

Коммит - это слепок, содержание которого представляет собой изменение файла, а также время его изменения.

Мы сделали 1-й коммит, в него попали два файлика.

![image](https://github.com/user-attachments/assets/0ac743ea-8894-4bf8-87a4-18c922192629)

С течением времени мы решили что - то поменять в файле main.go

И сделали 2-й коммит на наше изменение.

![image](https://github.com/user-attachments/assets/cebf191f-3111-4b92-93f3-994ddb79303c)
При этом этот коммит не будет хранить в себе весь файл main.go (это было бы неэффективно)
Поэтому Git хранит в рамках коммита наборы изменения.

Где хранятся коммиты, не в воздухе же?

Коммиты привязаны к веткам (brach)
Главная ветка - это main.
Там будут храниться ваши коммиты. Ветку можно понимать как направление развития вашего проекта.

А где сама ветка лежит? 
Она лежит в репозитории.

![image](https://github.com/user-attachments/assets/3be0cf65-c98c-4788-bce1-0ac30ffd2212)

А что такое репозиторий? Это папка `.git`. Там хранятся все ветки и как следствие коммиты. Главное не путать с проектом. Проект - это в данном случае два файла, а репозиторий - это всё что хранится в рамках ваших веток, коммитов и всех изменений, что у вас были.

Веток может быть не одна, но зачем? 

![image](https://github.com/user-attachments/assets/49e9d229-074b-471c-a6f3-bc9b061d6cb2)

Например, в главной ветке у тебя код, который вышел в продакшин (публично, для использования) и другой разработчик также пишет код, но уже с новыми фичами. Чтобы не поломать код в продакшене, хорошо иметь возможность писать этот код где - то на стороне, таким образом мы можем писать код в репозиторий, не трогая основную ветку. Когда уже сделаешь новые фичи, то их можно будет влить в основную.

Наличие веток позволяет различным людям из твоего проекта работать над несколькими частями проекта.


Для создания системы контроля версий проекта, нам необходимо инициализировать git репозиторий.
Эта папка будет следить за всеми изменениями этой папки и за всем вложенными папками.


git status - команда позволяющая узнать статус гита

![image](https://github.com/user-attachments/assets/41662788-12d2-4e08-a547-6340340d60b5)

Хорошо сделать конфиг нашего гита, то есть указать имя и email. Чтобы было ясно другим, кто сделал коммит в репозиторий и когда.

![image](https://github.com/user-attachments/assets/3554df87-2f91-4abe-99c4-a2d7aac14ef7)
user - это объект пользователя, где name его имя.
![image](https://github.com/user-attachments/assets/9a3f687a-b4ad-4a5a-b737-b615d20fcfe4)

чтобы указать своё имя пользователя, надо поставить его в двойные кавычки
![image](https://github.com/user-attachments/assets/e4a7712b-690a-470f-99e1-4b593b052114)

Также можно узнать и настроить глобальное имя пользователя

![image](https://github.com/user-attachments/assets/8c2d446c-7634-4a64-a671-1235d1b87b62)


---

Теперь можно делать коммиты

Но для начала посмотрим какой статус у нашего репозитория
![image](https://github.com/user-attachments/assets/0567576f-0b1f-4a7f-b65d-feb915154a8a)


Есть не отслеживаемый файл  `index.md`

Теперь надо познакомиться с тем, что такое не отслеживаемый файл и что такое `stage`?

![image](https://github.com/user-attachments/assets/d9bc811a-5f6b-4e16-8886-8c2671fb6ec9)

У нас есть один файл, который уже добавлен в репозиторий. 
Есть два файла которые мы изменили.
Чтобы закомитить `file 2`, нам нужно добавить его в Stage.

Что такое Stage?
Фактически, это такое промежуточное состояние, которое позволит тебе отслеживать файлы, которые ты захочешь за-commit-ить. 

Таким образом, это индекс, который позволит нам отслеживать файлы.

### Stage

В Git термин "stage" (или "индекс") относится к промежуточному состоянию, где вы можете подготовить изменения перед их коммитом в репозиторий. Это важный этап в процессе работы с Git, который позволяет вам контролировать, какие изменения будут включены в следующий коммит.

### Основные моменты о stage в Git:

1. **Подготовка изменений**: Когда вы вносите изменения в файлы в вашем проекте, они находятся в рабочем каталоге. Чтобы эти изменения стали частью следующего коммита, их нужно "добавить" в stage с помощью команды `git add`. Это позволяет вам избирательно выбирать, какие изменения вы хотите зафиксировать.
    
2. **Команда `git add`**: Эта команда добавляет изменения в stage. Например:
    
    `git add файл.txt`
    
    Это добавляет изменения в `файл.txt` в stage. Вы также можете добавить все изменения в текущем каталоге:
    
    `git add .`
    
3. **Коммит изменений**: После того как вы добавили изменения в stage, вы можете зафиксировать их с помощью команды `git commit`. Это создает новый коммит с подготовленными изменениями:
    
    `git commit -m "Описание изменений"`
    
4. **Проверка состояния**: Вы можете проверить, какие файлы находятся в stage, с помощью команды:
    
    `git status`
    
    Эта команда покажет вам, какие изменения были добавлены в stage и какие изменения еще не были подготовлены.
    
5. **Отмена изменений в stage**: Если вы хотите удалить файл из stage, вы можете использовать команду:
    
    `git reset файл.txt`
    
    Это переместит изменения из stage обратно в рабочий каталог.
    

### Пример рабочего процесса:

1. Вы изменяете файл.
2. Проверяете статус с помощью `git status`.
3. Добавляете изменения в stage с помощью `git add файл.txt`.
4. Проверяете статус снова, чтобы убедиться, что файл в stage.
5. Создаете коммит с помощью `git commit -m "Описание изменений"`.

Таким образом, stage в Git дает вам гибкость и контроль над тем, какие изменения вы хотите зафиксировать в вашем репозитории.

### А зачем нам нужен Stage если мы можем сразу всё закоммитить?

Хотя в Git действительно можно сразу закоммитить все изменения, использование stage (индекса) предоставляет несколько преимуществ, которые делают процесс управления версиями более гибким и удобным. Вот основные причины, почему stage важен:

### 1. **Контроль над коммитами**

Stage позволяет вам выбирать, какие изменения вы хотите включить в коммит. Это особенно полезно, если вы сделали несколько изменений в разных частях проекта, и хотите зафиксировать их в отдельных коммитах. Например, вы можете добавить изменения в один файл в один коммит, а изменения в другом — в следующий.

### 2. **Чистота и организованность истории коммитов**

Используя stage, вы можете создавать более осмысленные и логически структурированные коммиты. Это помогает в дальнейшем анализировать историю изменений и понимать, какие изменения были сделаны и почему.

### 3. **Проверка изменений перед коммитом**

Stage позволяет вам проверить, какие изменения вы собираетесь закоммитить, прежде чем это сделать. Вы можете использовать команду `git status` или `git diff --cached`, чтобы увидеть, что именно будет добавлено в коммит.

### 4. **Группировка изменений**

Если вы работаете над несколькими задачами одновременно, вы можете временно сохранить изменения в stage и продолжить работу над другой задачей. Это позволяет вам не терять прогресс и в дальнейшем возвращаться к ним.

### 5. **Изоляция изменений**

Stage позволяет вам изолировать изменения, которые еще не готовы к коммиту. Вы можете подготовить часть изменений, а другие оставить в рабочем каталоге для дальнейшей доработки.

### Пример использования stage:

Предположим, вы работаете над двумя задачами: исправляете ошибку в одном файле и добавляете новую функцию в другом. Вместо того чтобы закоммитить оба изменения сразу, вы можете:

1. Закоммитить исправление ошибки, добавив только изменения в соответствующий файл в stage.
2. Затем добавить изменения для новой функции в stage и закоммитить их отдельно.

Это делает вашу историю коммитов более понятной и структурированной.

Таким образом, хотя вы можете закоммитить все изменения сразу, использование stage предлагает более гибкий и организованный подход к управлению версиями.

Можно ещё удалить файл из `Stage` с помощью команды:

![image](https://github.com/user-attachments/assets/aa9d0be0-1e71-4bed-b243-7906d1406978)

А теперь уже возвращаемся к `commit` 

Нам нужно зафиксировать наши изменения.
git commit состоит из названия коммита и описания.

![image](https://github.com/user-attachments/assets/afb220cf-cc65-4b71-b5a3-7517ccba60b0)

-m значит мы указываем название коммита в кавычках после этого флага

(aborting commit due to empty commit message  - прерывание фиксации из-за пустого сообщения о фиксации)


# История коммитов

Чтобы посмотреть историю коммитов, нужно вписать в командную строку:
`git log`

git log - выведет все текущие коммиты

![image](https://github.com/user-attachments/assets/7beaa30b-6de2-4576-bd6e-3d862a0e598f)
Здесь указан коммит с неким идентификатором. У каждого коммита есть свой уникальный идентификатор по которому мы можем перейти к этому коммиту, чтобы указать что мы хотим посмотреть теперь состояние нашего файла здесь.

Тут указана ветка в которую добавлен commit
Автор
Дата 
И название коммита


Тут мы создали новый файл и добавили его в stage

![image](https://github.com/user-attachments/assets/36a32d4b-60ba-46a7-9260-7b4a4564a378)

И смотрим его статус.

### Из интересного, что есть команда git restore --stage имя файла

### Что делает `git restore --stage`?

Команда `git restore --stage <файл>` используется для:

1. **Удаления файла из индекса**:
    
    - Если вы добавили файл в индекс с помощью `git add`, но передумали и хотите отменить это действие, вы можете использовать `git restore --stage <файл>`. Это уберет файл из индекса, но изменения в рабочем каталоге останутся нетронутыми.
2. **Восстановления файла в индексе до состояния последнего коммита**:
    
    - Если вы внесли изменения в файл, и хотите вернуть его в состояние, в котором он был в последнем коммите (удалив изменения из индекса), вы также можете использовать эту команду.

### Примеры использования

1. **Удаление файла из индекса**:
    
    `git add myfile.txt  # Добавляем файл в индекс 
	`git restore --stage myfile.txt  # Убираем файл из индекса``
    
    В этом случае изменения в `myfile.txt` останутся в рабочем каталоге, но файл не будет включен в следующий коммит.
    
2. **Восстановление файла до состояния последнего коммита**:
    
    `git add myfile.txt  # Добавляем файл в индекс 
    `# Вносим изменения в myfile.txt 
	```git restore --stage myfile.txt  # Возвращаем файл в состояние последнего коммита```   
    
    Теперь файл в индексе будет соответствовать последнему коммиту, а изменения в рабочем каталоге останутся.
### Важные моменты

- Команда `git restore --stage` не удаляет изменения в рабочем каталоге. Она только управляет состоянием индекса.
- Если вы хотите вернуть файл в рабочем каталоге до состояния последнего коммита, используйте `git restore <файл>` без флага `--stage`.
### Как должны называться коммиты

Названия должны отображать всё что было сделано в коммите.

---

Коммиты идут от самого верхнего к самому нижнем, где верхние это самые новые коммиты, а нижние старые.

![image](https://github.com/user-attachments/assets/20512243-29ab-40b1-a8df-627f72e3c94b)

---

Как перемещаться по коммитам?

git checkout и id коммита

git checkout master - переключиться к последнему коммиту 

---

Перейдём к веткам.
Напомню, что они нужны для того чтобы работать над несколькими фичами проекта разными разработчиками, чтобы потом их слить в main ветку.

![image](https://github.com/user-attachments/assets/2864a256-6eaf-4180-bc31-051af27cf09c)


---

git branch - позволит нам увидеть все ветки нашего репозитория.

![image](https://github.com/user-attachments/assets/221b869c-5930-4b9a-a155-e36cdefc5708)

Звёздочкой помечается ветка в которой мы находимся ещё и зелёным.

Чтобы создать новую ветку, используют git branch имя_ветки

![image](https://github.com/user-attachments/assets/2015f0b0-2e14-47bd-a5f5-7459931c2383)

Когда мы создаём новую ветку, то у нас в новой ветке будут находиться те же самые коммиты от ветки от которой мы создали нашу новую

Таким образом переносятся те же коммиты, что были в ветке main в ветку develop

![image](https://github.com/user-attachments/assets/8310de5d-12c7-4112-a4cd-a5a5a3500b09)

Для того чтобы перейти на новую ветку, нужно вбить команду git checkout имя_ветки

![image](https://github.com/user-attachments/assets/e1410c41-8564-4e61-86ab-8b27d1c6740e)

Как видишь коммиты мы не потеряли и тут находятся те же коммиты, что были раньше.

Ещё раз, для чего мы это сделали? 

Для того чтобы отделить стабильный код (master branch) от нестабильного (develop branch)

Но когда нестабильный код на ветке develop стал готов чтобы выставить его на продакшен, то возникает вопрос:
Как слить изменения из ветки develop в master?

![image](https://github.com/user-attachments/assets/8dd66a37-f0e3-4b77-a8da-2e653711cc0c)

Слияние - merge - это возможность влить одну ветку в другую, то есть все изменения на ветке develop в master (ещё называют main)

Мы должны находиться в той ветке, в которую мы хотим слить изменения некой другой ветки.

Чтобы слить одну ветку с другой, надо использовать `git merge имя_ветки_которую_хочешь_слить_с_текущей`

Вот как выглядит на практике

![image](https://github.com/user-attachments/assets/a12a3279-4e08-4e19-a842-b0bcda0d03c9)

# Что такое Head

Head - это указатель на тот коммит в котором ты находишься и от которого будет сделан следующий коммит если ты его сделаешь

![image](https://github.com/user-attachments/assets/c7b6ea67-f1d5-4e2d-907b-207e65c96d73)

Head, по умолчанию, когда мы перемещаемся между ветками, автоматически становится последним коммитом этой ветки.

Если бы в `main` ветке было бы всего лишь два коммита, то при команде` git checkout`, **HEAD** бы переместился на `commit 2`, как только мы перемещаемся на ветку `develop`, то **HEAD** переместится на `commit 3`. 

# Теги

Тег - это просто имя коммита. Обычно туда вписывают версию

git tag --- показывает все теги репозитория
git tag имя_тега - определяет тег на текущем коммите

По сути это просто удобное имя коммита, а не символьная строка

![image](https://github.com/user-attachments/assets/43c61067-1f6e-48ba-9a73-671fbc14228e)
Вот тут где **HEAD** указан тег коммита 


# Команда switch

Позволяет быстро переключить ветку, либо специальным флагом создать её.

Допустим мы находимся на ветке мастер, а хотим переключить на ветку develop

![image](https://github.com/user-attachments/assets/dd55c424-701b-4b0e-a38e-337bc966233e)
Она делает тоже самое что checkout, но работает только с ветками.


Можно также переключиться на коммит, но нужен флаг --detach

![image](https://github.com/user-attachments/assets/77262578-f07b-4ac4-916f-47ad4e740610)

Можно также сразу создать ветку и сразу на неё переместиться с помощью флага -c 

![image](https://github.com/user-attachments/assets/9b13ea7e-3ebd-4eab-93ff-49c3349d7927)

---

Давайте разберем понятие "detached HEAD" простыми словами.

### Что такое "detached HEAD"?

1. **Что такое HEAD?**
   - В Git `HEAD` — это указатель, который показывает, на какой коммит или ветку вы сейчас находитесь. Это как "ваш текущий местоположение" в истории проекта.

2. **Что значит "detached"?**
   - "Detached" переводится как "отсоединенный". Это значит, что `HEAD` не указывает на ветку, а на конкретный коммит. Вы можете это представить как если бы вы были "отключены" от веток.

### Когда это происходит?

Вы можете попасть в состояние "detached HEAD", когда:

- Вы используете команду `git checkout` и указываете конкретный коммит или тег, например:

  ```bash
  git checkout <commit-hash>
  ```

### Что это значит для вас?

- **Вы можете делать изменения**: Вы можете редактировать файлы и делать коммиты.
- **Но**: Эти изменения не будут привязаны к какой-либо ветке. Это значит, что если вы сделаете новый коммит, и потом переключитесь обратно на ветку, вы не сможете легко найти этот коммит, если не создадите для него отдельную ветку.

### Как выйти из состояния "detached HEAD"?

1. **Переключиться на существующую ветку**:
   - Например, если вы хотите вернуться на ветку `main`, вы можете выполнить:

     ```bash
     git checkout main
     ```

2. **Создать новую ветку**:
   - Если вы хотите сохранить изменения, которые вы сделали в состоянии "detached HEAD", вы можете создать новую ветку:

     ```bash
     git checkout -b new-branch-name
     ```

   Это создаст новую ветку, и ваши изменения будут сохранены в ней.

### Пример

Представьте, что вы смотрите на старую версию вашего проекта (например, на коммит от прошлого). Если вы внесете изменения и не создадите новую ветку, эти изменения могут "потеряться", когда вы вернетесь к текущей версии проекта.

Отличный вопрос! Давайте разберем, почему может быть полезно находиться в состоянии "detached HEAD", несмотря на то, что создание ветки — это более безопасный и удобный способ работы.

### Причины использования "detached HEAD":

1. **Просмотр старых коммитов**:
   - Иногда вам нужно просто посмотреть, как выглядел проект в определенный момент времени. В таком случае вы можете использовать `git checkout <commit-hash>`, чтобы временно переключиться на старую версию, не создавая ветку.

2. **Тестирование изменений**:
   - Вы можете тестировать изменения или исправления в конкретном коммите, не беспокоясь о том, чтобы создавать новую ветку. Это может быть полезно для быстрого тестирования или отладки.

3. **Эксперименты**:
   - Если вы хотите поэкспериментировать с кодом, но не хотите, чтобы эти эксперименты влияли на вашу основную ветку, вы можете сделать это в состоянии "detached HEAD". Если вам не понравится результат, вы просто вернетесь на свою ветку и ничего не потеряете.

4. **Создание коммитов для дальнейшего использования**:
   - Вы можете сделать коммит в состоянии "detached HEAD", а затем, если он вам понравится, создать новую ветку из этого состояния, чтобы сохранить изменения. Это может быть полезно, если вы не уверены, что хотите продолжать работу с этими изменениями.

### Когда лучше создать ветку?

- Если вы планируете вносить значительные изменения или хотите сохранить свою работу, лучше создать новую ветку. Это даст вам больше контроля и упростит управление изменениями.

### Заключение

Состояние "detached HEAD" может быть полезным для временной работы, просмотра и тестирования, но для долгосрочных изменений и сохранения работы создание ветки — более предпочтительный вариант. 

---

# Удаление файлов, веток, а также откатов изменений, для того чтобы если ты сделал что - то не так, ты мог всегда вернуть какие - то изменения.

### Как удалить файл?

Например, ты находишься в ветке `master` и ты хочешь удалить какой - то файл, который больше не нужен.

Способы:
1. Просто удаляешь файл из проекта с помощью IDEA из папки
   Теперь когда ты удалишь файл и напишешь `git status`
   ![image](https://github.com/user-attachments/assets/5c7053e1-c7dc-4909-ae5f-86f033e3eca4)
2. git rm
   ![image](https://github.com/user-attachments/assets/d2f4d4dc-0dbd-4504-a4bd-def7f0ab77bf)
   как видишь мы тут также удаляем файл, но через консоль. Он удаляется из проекта, а также перестаёт отслеживаться.
   
   
   git ls-files отображает все файлы в репозитории, которые отслеживаются git
   


# Как откатывать изменения?

Вот мы добавили строчку в файл first-dock.md

![image](https://github.com/user-attachments/assets/6c39a680-a394-45c3-8a00-a7b4fff54c61)

Чтобы вернуть состояние до изменений мы можем использовать команду `git restore file_name`
Тоже самое можно сделать с помощью `git checkout file_name`. Мы также вернёмся к исходному состоянию.

Если мы используем `git checkout .`, то мы вернём все состояния файлов до последнего изменения.

---

# git clean

Эта команда удалит всё что не находится в индексе. 

![image](https://github.com/user-attachments/assets/1f553ac4-f02b-4817-8b4c-8ba0784a97f9)

Можно также узнать что именно будет удалено с помощью `git clean -dn`, -d выведет сообщение, а -n укажет что именно было удалено

![image](https://github.com/user-attachments/assets/1fcb308e-131e-489f-8582-8730a8520537)

-f --- форсирует удаление, тем самым мы удаляем все файлы, что вне индекса.


---

![image](https://github.com/user-attachments/assets/64a83406-1b5b-4d8b-b482-27e27f532cd2)

-m второй раз позволяет добавить описание к коммиту

![image](https://github.com/user-attachments/assets/3ba88b3b-879c-40d9-a232-89f0a64524f3)


Что тут пишут?
например: закрыто по задаче такой - то, либо требуется тестирование, короче что - то дополнительное.

---

git commit позволит открыть редактор vim

![image](https://github.com/user-attachments/assets/48b27682-9703-4eff-9fee-9269f18c42cd)


vim - это отдельный текстовый редактор.
Зачем нужно?
Потому что одной строкой неудобно в кавычках писать описание, а тут описание можно написать в отдельном большом редакторе.

Как только ты выйдешь из вим (сохранив и закрыв его) у тебя будет сделан commit
![image](https://github.com/user-attachments/assets/3fe6af8b-f230-4190-bb71-925fb31ab261)


---

`git commit --amend -m "Added markdown text"` позволяет изменить описание текста последнего коммита

`git commit --amend --no-edit` позволяет добавить к последнему коммиту файл которые индексирован

![image](https://github.com/user-attachments/assets/9ca2c2ba-2910-4b35-b275-3f0b7c62ba75)

---

# Как удалить commit?

![image](https://github.com/user-attachments/assets/238c1703-b69d-4480-9f16-05ffd1fa30ae)

Появился коммит, но бизнес сказал откатить коммит который ты сделал, либо мы решаем что этот коммит не нужен.

Есть команда `git reset`

## Soft

Soft режим - говорит, что мы хотим мягко откатить изменения. Это значит, что мы хотим удалить коммит, но оставить все изменения в index (или ещё называют Stage) состоянии
![image](https://github.com/user-attachments/assets/d5473205-4ae1-4ef8-a9c0-2bb14f08af6e)


Но для этого тебе нужно сказать от какого коммита мы удалим верхние коммиты. Для этого нужно указатель `HEAD` сместить на предыдущий коммит

![image](https://github.com/user-attachments/assets/70e84da8-a8e6-4ad1-8229-19b5699d25ed)

Для этого укажи через `~` насколько коммитов относительно текущего ты хочешь откатиться.

## Medium (по умолчанию)

![image](https://github.com/user-attachments/assets/55bfd176-60db-41c8-8b76-edd4e1ca68c3)
Эта строка уже удаляет коммит также, однако убирает из Stage всё что находилось в коммите

## Hard reset

![image](https://github.com/user-attachments/assets/78464d68-8cb6-4aaf-b5da-0ab1437f36fd)

Тут мы не просто удалим коммит, но и всё его содержимое 


# Удаление веток

Для того чтобы удалить конкретную ветку, тебе нельзя в ней находится, иначе получишь ошибку

![image](https://github.com/user-attachments/assets/e0b4db1c-7ce7-4bcc-af5d-967ad7209937)


Важно понимать, что если мы удалим ветку, то мы потеряем все её коммиты, так что удалять следует когда ты уже сделал слияние веток.

![image](https://github.com/user-attachments/assets/419f958c-dfe9-40d6-a40b-966f920e9e7a)

Щас всё нормально

---

Что если в режиме detached мы попробуем внести изменения?

# Git detach head

Что будет если в нём внести изменения

У нас есть некое число коммитов
![image](https://github.com/user-attachments/assets/71814919-2128-491a-9133-14fa458cafaf)

Допустим при добавлении коммита мы забыли что - то сделать
И мы хотим внести изменения

Для этого мы можем перейти к коммиту с помощью 

![image](https://github.com/user-attachments/assets/63ac7bca-8686-4d08-aa56-263ff9d82ab7)


Теперь мы находимся в отсоединённом detach head 

Так что если мы посмотрим git status, то увидим
![image](https://github.com/user-attachments/assets/f3157617-84d7-465c-b5ba-173eb328acb6)


А если ввести git branch, то увидим это

![image](https://github.com/user-attachments/assets/153a2ec7-79b0-4ddc-98cd-3913bf954751)

Но что будет если мы захотим ввести какие - то изменения
![image](https://github.com/user-attachments/assets/c565af59-853c-49f7-a0ff-1a8f2d79f678)


![image](https://github.com/user-attachments/assets/003b1b44-19af-4512-a6e6-b09809afd615)

Теперь мы видим изменения в изменённом документе, который мы уже отслеживаем но в котором произошло изменение

![image](https://github.com/user-attachments/assets/bb00c4ed-a650-4b5e-a768-bc1655ae1637)

Добавляем в отслеживаемые

![image](https://github.com/user-attachments/assets/2c8c2d94-4ba9-4f54-8706-21533e7d592e)

git log покажет что появился новый коммит

![image](https://github.com/user-attachments/assets/a0440f5f-8a11-425c-9359-4ade72de9cc5)


![image](https://github.com/user-attachments/assets/09609a6e-71cf-4ea4-b0c9-54cd072af7bd)


Если мы попробуем свичнуться на другой коммит, то мы потеряем этот коммит, но не доконца

![image](https://github.com/user-attachments/assets/c21f4dc5-ad7f-4fa2-900e-93c980796c3e)


Нам нужно создать новый branch и указать чтобы он был добавлен в новый коммит

![image](https://github.com/user-attachments/assets/9110f052-2aba-4566-91f6-122115cba3d4)


последние числа - это id коммита

Важно именно  перенести в новую ветку, прежде чем мы переместимся на новую ветку, иначе потеряем идентификатор нашего коммита

теперь переходим в новую ветку
![image](https://github.com/user-attachments/assets/3600aad3-1535-4b09-a71f-3dfe043386e3)


Но тут конфликт слияние.

### Конфликт слияния

Когда они происходят? Когда ты сделал коммит в ветке другой (отличной от master), а другой разраб сделал изменения в том же файле и далее сделал коммит, а потом мы сделали merge веток, мы получим конфликт, и тут надо решать. То есть мы слили ветки в один и тот же файл и Git не может понять какой из них принять. Возможно они оба изменения нам нужны.

Чтобы узнать какие коммиты конфликтуют, надо вбить эту команду

![image](https://github.com/user-attachments/assets/bb026a4d-15e2-4d28-bbac-1bd1f7a3b059)


![image](https://github.com/user-attachments/assets/d693248c-8a53-420d-837e-6ad8a4bc0296)


Далее ты редачишь в Idea кофликт и решаешь как слить изменения. (Там будет в середине окно в котором ты решаешь как слить части с master и develop (ты сам создал эту ветку)).

### Как реализовать конфликт?)

Создание конфликта в Git — это полезный способ понять, как он работает. Вот пошаговая инструкция, как вы можете это сделать:

### 1. **Создайте новый репозиторий**
Если у вас еще нет репозитория, создайте новый:
```bash
mkdir my-repo
cd my-repo
git init
```

### 2. **Создайте файл и сделайте первый коммит**
Создайте файл, добавьте в него текст и зафиксируйте изменения:
```bash
echo "Это первая версия файла." > example.txt
git add example.txt
git commit -m "Первый коммит: добавлен example.txt"
```

### 3. **Создайте новую ветку**
Создайте новую ветку, чтобы работать над изменениями:
```bash
git checkout -b feature-branch
```

### 4. **Измените файл в новой ветке**
Отредактируйте файл в новой ветке:
```bash
echo "Изменения в ветке feature-branch." >> example.txt
git add example.txt
git commit -m "Изменения в feature-branch"
```

### 5. **Вернитесь в основную ветку и внесите конфликтующие изменения**
Переключитесь обратно на основную ветку и внесите изменения в тот же файл:
```bash
git checkout main
echo "Изменения в основной ветке." >> example.txt
git add example.txt
git commit -m "Изменения в основной ветке"
```

### 6. **Попробуйте слить ветки**
Теперь, когда у вас есть изменения в обеих ветках, попробуйте слить `feature-branch` в `main`:
```bash
git merge feature-branch
```

### 7. **Конфликт**
На этом этапе вы должны увидеть сообщение о конфликте, так как обе ветки изменили один и тот же файл. Git сообщит вам о конфликте и пометит файл как "необработанный".

### 8. **Разрешите конфликт**
Теперь вы можете открыть файл в Vim или любом другом редакторе, чтобы увидеть конфликтующие изменения и разрешить их. После редактирования не забудьте сделать коммит.

### Заключение
Теперь вы знаете, как создать конфликт в Git. Это может быть полезно для практики разрешения конфликтов и улучшения ваших навыков работы с Git.

---
### .gitignore

Мы можем изначально решить какие файлы не будут попадать в `stage` и как следствие в commit.
Этот файл обязательно должен быть в репозитории чтобы он знал, что игнорировать.

![image](https://github.com/user-attachments/assets/de4f9898-349d-425b-8d5c-edf3782bf3b5)

Вот пример как исключить файл log.txt из .gitignore 
Мы просто пишем файл который должен включаться в игнорирование
Если только у тебя уже в индекс добавлен файл который ты хочешь игнорировать, то нужно сначала его оттуда вытащить

---
Можно также использовать целые паттерны в git commit
например так:

![image](https://github.com/user-attachments/assets/492c3a61-845a-40c8-ad78-1cbb69c2037a)

Таким образом он будет игнорировать всё что заканчивается .txt

![image](https://github.com/user-attachments/assets/5f564c8b-54f7-4978-8d72-b9e3e2198374)


### .gitkeep

![image](https://github.com/user-attachments/assets/470b71a3-a8ae-41d4-acfc-c474da44ab62)


---


### Stash

Какую проблему решает?




---
Links:
[[]]
